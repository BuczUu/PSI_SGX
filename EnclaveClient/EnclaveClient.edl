enclave {
    from "sgx_tkey_exchange.edl" import *;

    include "sgx_key_exchange.h"
    include "sgx_trts.h"

    trusted {
        public sgx_status_t enclave_init_ra(int b_pse,
                                            [out] sgx_ra_context_t *p_context);
        public sgx_status_t enclave_ra_close(sgx_ra_context_t context);
        
        public sgx_status_t verify_att_result_mac(sgx_ra_context_t context,
                                                  [in,size=message_size] uint8_t* message, 
                                                  size_t message_size, 
                                                  [in,size=mac_size] uint8_t* mac, 
                                                  size_t mac_size);
        
        public sgx_status_t verify_server_mrenclave(sgx_ra_context_t context,
                                                    [in, size=32] uint8_t* received_mrenclave,
                                                    [in, size=32] uint8_t* expected_mrenclave,
                                                    [out] int* match);

        /* Enclave-to-Enclave Key Exchange (client side) */
        public sgx_status_t kx_client_init(
            [out, size=64] uint8_t* client_pubkey);

        public sgx_status_t kx_client_finish(
            [in, size=64] const uint8_t* server_pubkey);

        public sgx_status_t kx_encrypt_client(
            [in, count=plain_count] const uint32_t* plaintext,
            uint32_t plain_count,
            [in, size=12] const uint8_t* iv,
            [out, size=cipher_size] uint8_t* ciphertext,
            uint32_t cipher_size,
            [out, size=16] uint8_t* gcm_tag);

        public sgx_status_t kx_decrypt_client(
            [in, size=cipher_size] const uint8_t* ciphertext,
            uint32_t cipher_size,
            [in, size=12] const uint8_t* iv,
            [in, size=16] const uint8_t* gcm_tag,
            [out, count=plain_max] uint32_t* plaintext,
            uint32_t plain_max,
            [out] uint32_t* plain_count);

        public sgx_status_t ecall_ra_encrypt_client(
            sgx_ra_context_t context,
            [in, count=plain_count] const uint32_t* plaintext,
            uint32_t plain_count,
            [in, size=12] const uint8_t* iv,
            [out, size=cipher_size] uint8_t* ciphertext,
            uint32_t cipher_size,
            [out, size=16] uint8_t* gcm_tag);

        public sgx_status_t ecall_ra_decrypt_client(
            sgx_ra_context_t context,
            [in, size=cipher_size] const uint8_t* ciphertext,
            uint32_t cipher_size,
            [in, size=12] const uint8_t* iv,
            [in, size=16] const uint8_t* gcm_tag,
            [out, count=plain_max] uint32_t* plaintext,
            uint32_t plain_max,
            [out] uint32_t* plain_count);
    };
};
